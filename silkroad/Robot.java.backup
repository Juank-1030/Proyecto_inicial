package silkroad;

/**
 * Robot - clase de compatibilidad que delega a BasicRobot.
 * Mantiene compatibilidad con c칩digo existente.
 * Para extensibilidad, usar RobotAbstract como clase base.
 */
public class Robot extends BasicRobot {

    /**
     * Construye un robot con tama침o fijo y color aleatorio.
     * 
     * @param visible true para hacerlo visible tras construir
     */
    public Robot(boolean visible) {
        this.size = 15;
        this.positionX = 36;
        this.positionY = 58;
        this.color = getRandomColor();

        String eyeAndMouthColor = (color.equals("black") || color.equals("brown")) ? "white" : "black";

        robotHead = new Rectangle();
        robotHead.changeColor(color);
        robotHead.changeSize(size, size);
        robotHead.setPosition(positionX, positionY);

        int eyeSize = size / 6;
        leftEye = new Circle();
        leftEye.changeColor(eyeAndMouthColor);
        leftEye.changeSize(eyeSize);
        leftEye.setPosition(positionX + size - 14, positionY + size / 4);

        rightEye = new Circle();
        rightEye.changeColor(eyeAndMouthColor);
        rightEye.changeSize(eyeSize);
        rightEye.setPosition(positionX + size - 4, positionY + size / 4);

        mouth = new Rectangle();
        mouth.changeColor(eyeAndMouthColor);
        mouth.changeSize(1, 10);
        mouth.setPosition(positionX + size / 6, positionY + size - (size / 10) - 1);
        if (visible) {
            makeVisible();
        }
        this.isVisible = visible;
    }

    /**
     * Selecciona un color aleatorio para el robot.
     * 
     * @return color elegido
     */
    private String getRandomColor() {
        String[] colors = { "red", "blue", "green", "yellow", "magenta", "cyan", "black", "brown", "purple", "orange" };
        Random rand = new Random();
        return colors[rand.nextInt(colors.length)];
    }

    /**
     * Mueve el robot a una posici칩n espec칤fica mostrando el desplazamiento.
     * 
     * @param x nueva coordenada X
     * @param y nueva coordenada Y
     */
    public void moveTo(int x, int y) {
        makeVisible();
        slowMoveTo(x, y);
    }

    /**
     * Movimiento gradual del robot desde su posici칩n actual hasta (targetX,
     * targetY).
     */
    private void slowMoveTo(int targetX, int targetY) {
        // 游댳 Diferencia entre la posici칩n actual y el destino
        int deltaX = targetX - positionX;
        int deltaY = targetY - positionY;

        // 游댳 N칰mero de pasos = distancia m치xima en px
        int steps = Math.max(Math.abs(deltaX), Math.abs(deltaY));
        if (steps == 0)
            return; // ya est치 en destino

        // 游댳 Control de velocidad (mayor = m치s r치pido)
        int speed = 5;

        // 游댳 Incremento por paso (positivo o negativo)
        double stepX = (double) deltaX / steps * speed;
        double stepY = (double) deltaY / steps * speed;

        for (int i = 0; i < steps; i += speed) {
            positionX += stepX;
            positionY += stepY;
            updateParts();
        }

        // 游댳 Asegurar que termine exactamente en el destino
        positionX = targetX;
        positionY = targetY;
        updateParts();
    }

    /**
     * Actualiza las posiciones de las partes del robot basadas en positionX/Y
     * actuales.
     */
    private void updateParts() {
        robotHead.setPosition(positionX, positionY);
        leftEye.setPosition(positionX + size - 14, positionY + size / 4);
        rightEye.setPosition(positionX + size - 4, positionY + size / 4);
        mouth.setPosition(positionX + size / 6, positionY + size - (size / 10) - 1);

        robotHead.makeVisible();
        leftEye.makeVisible();
        rightEye.makeVisible();
        mouth.makeVisible();
    }

    /**
     * Coloca el robot directamente en una ubicaci칩n espec칤fica sin animaci칩n.
     * 
     * @param x coordenada X donde aparecer치
     * @param y coordenada Y donde aparecer치
     */
    public void placeTo(int x, int y) {
        positionX = x;
        positionY = y;

        // Actualizar posiciones de todas las partes
        robotHead.setPosition(positionX, positionY);
        leftEye.setPosition(positionX + size - 14, positionY + size / 4);
        rightEye.setPosition(positionX + size - 4, positionY + size / 4);
        mouth.setPosition(positionX + size / 6, positionY + size - (size / 10) - 1);

        // Asegurar que todas las partes sean visibles
        robotHead.makeVisible();
        leftEye.makeVisible();
        rightEye.makeVisible();
        mouth.makeVisible();

        isVisible = true;
    }

    /**
     * Hace visible el robot (todas sus partes) si no lo est치.
     */
    public void makeVisible() {
        if (!isVisible) {
            robotHead.makeVisible();
            leftEye.makeVisible();
            rightEye.makeVisible();
            mouth.makeVisible();
            isVisible = true;
        }
    }

    /**
     * Hace invisible el robot (todas sus partes) si est치 visible.
     */
    public void makeInvisible() {
        if (isVisible) {
            robotHead.makeInvisible();
            leftEye.makeInvisible();
            rightEye.makeInvisible();
            mouth.makeInvisible();
            isVisible = false;
        }
    }

    /**
     * @return coordenada X actual.
     */
    public int getX() {
        return positionX;
    }

    /**
     * @return coordenada Y actual.
     */
    public int getY() {
        return positionY;
    }

}